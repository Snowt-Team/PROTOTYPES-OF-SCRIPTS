-- WindUI
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Locals
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local CurrentCamera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local CoreGui = game:GetService("CoreGui")

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end

local Confirmed = false

WindUI:Popup({
    Title = gradient("SNT HUB", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),
    Icon = "info",
    Content = gradient("This script made by", Color3.fromHex("#10eb3c"), Color3.fromHex("#67c97a")) .. gradient(" SnowT", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Buttons = {
        {
            Title = gradient("Cancel", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),
            Callback = function() end,
            Variant = "Tertiary", -- Primary, Secondary, Tertiary
        },
        {
            Title = gradient("Load", Color3.fromHex("#90f09e"), Color3.fromHex("#13ed34")),
            Callback = function() Confirmed = true end,
            Variant = "Secondary", -- Primary, Secondary, Tertiary
        }
    }
})

repeat task.wait() until Confirmed

WindUI:Notify({
    Title = gradient("SNT HUB", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),
    Content = "Скрипт успешно загружен!",
    Icon = "check-circle",
    Duration = 3,
})

-- Window
local Window = WindUI:CreateWindow({
    Title = gradient("SNT&MirrozzScript [Beta]", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Icon = "infinity",
    Author = gradient("Murder Mystery 2", Color3.fromHex("#1bf2b2"), Color3.fromHex("#1bcbf2")),
    Folder = "WindUI",
    Size = UDim2.fromOffset(300, 270),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    UserEnabled = true,
    HasOutline = true,
})

-- Open Button
Window:EditOpenButton({
    Title = "Open UI",
    Icon = "monitor",
    CornerRadius = UDim.new(2, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("1E213D"),
        Color3.fromHex("1F75FE")
    ),
    Draggable = true,
})

-- Tabs
local Tabs = {
    MainTab = Window:Tab({ Title = gradient("MAIN", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "terminal" }),
    CharacterTab = Window:Tab({ Title = gradient("CHARACTER", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "file-cog" }),
    TeleportTab = Window:Tab({ Title = gradient("TELEPORT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "user" }),
    EspTab = Window:Tab({ Title = gradient("ESP", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "eye" }),
    AimbotTab = Window:Tab({ Title = gradient("AIMBOT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "arrow-right" }),
    bs = Window:Divider(),
    InnocentTab = Window:Tab({ Title = gradient("INNOCENT", Color3.fromHex("#0ff707"), Color3.fromHex("#1e690c")), Icon = "circle" 
}),
    MurderTab = Window:Tab({ Title = gradient("MURDER", Color3.fromHex("#e80909"), Color3.fromHex("#630404")), Icon = "circle"
}),
    SheriffTab = Window:Tab({
        Title = gradient("SHERIFF", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")), Icon = "circle" 
    }),
    AutoFarm = Window:Tab({ Title = gradient("AUTOFARM", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "user"}),
    ServerTab = Window:Tab({ Title = gradient("SERVER", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "atom", }),
    beed = Window:Divider(),
    SettingsTab = Window:Tab({ Title = gradient("SETTINGS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "code" }),
    ChangelogsTab = Window:Tab({ Title = gradient("CHANGELOGS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "info"}),
    SocialsTab = Window:Tab({ Title = gradient("SOCIALS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "star"}),
    b = Window:Divider(),
    WindowTab = Window:Tab({ Title = gradient("CONFIGURATION", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "settings", Desc = "Manage window settings and file configurations." }),
    CreateThemeTab = Window:Tab({ Title = gradient("THEMES", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "palette", Desc = "Design and apply custom themes." }),
}

-- Character
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CharacterSettings = {
    WalkSpeed = {Value = 16, Default = 16, Locked = false},
    JumpPower = {Value = 50, Default = 50, Locked = false}
}

local function updateCharacter()
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if not CharacterSettings.WalkSpeed.Locked then
            humanoid.WalkSpeed = CharacterSettings.WalkSpeed.Value
        end
        if not CharacterSettings.JumpPower.Locked then
            humanoid.JumpPower = CharacterSettings.JumpPower.Value
        end
    end
end
Tabs.CharacterTab:Section({Title = gradient("Walkspeed", Color3.fromHex("#ff0000"), Color3.fromHex("#300000"))})

Tabs.CharacterTab:Slider({
    Title = "Walkspeed",
    Value = {Min = 0, Max = 200, Default = 16},
    Callback = function(value)
        CharacterSettings.WalkSpeed.Value = value
        updateCharacter()
    end
})

Tabs.CharacterTab:Button({
    Title = "Reset walkspeed",
    Callback = function()
        CharacterSettings.WalkSpeed.Value = CharacterSettings.WalkSpeed.Default
        updateCharacter()
    end
})

Tabs.CharacterTab:Toggle({
    Title = "Block walkspeed",
    Default = false,
    Callback = function(state)
        CharacterSettings.WalkSpeed.Locked = state
        updateCharacter()
    end
})

Tabs.CharacterTab:Section({Title = gradient("JumpPower", Color3.fromHex("#001aff"), Color3.fromHex("#020524"))})

Tabs.CharacterTab:Slider({
    Title = "Jumppower",
    Value = {Min = 0, Max = 200, Default = 50},
    Callback = function(value)
        CharacterSettings.JumpPower.Value = value
        updateCharacter()
    end
})


Tabs.CharacterTab:Button({
    Title = "Reset jumppower",
    Callback = function()
        CharacterSettings.JumpPower.Value = CharacterSettings.JumpPower.Default
        updateCharacter()
    end
})

Tabs.CharacterTab:Toggle({
    Title = "Block jumppower",
    Default = false,
    Callback = function(state)
        CharacterSettings.JumpPower.Locked = state
        updateCharacter()
    end
})

-- ESP
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

local ESPConfig = {
    HighlightMurderer = false,
    HighlightInnocent = false,
    HighlightSheriff = false
}

local Murder, Sheriff, Hero
local roles = {}

function CreateHighlight(player)
    if player ~= LP and player.Character and not player.Character:FindFirstChild("Highlight") then
        local highlight = Instance.new("Highlight")
        highlight.Parent = player.Character
        highlight.Adornee = player.Character
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        return highlight
    end
    return player.Character and player.Character:FindFirstChild("Highlight")
end

function RemoveAllHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Highlight") then
            player.Character.Highlight:Destroy()
        end
    end
end

function UpdateHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            local highlight = player.Character:FindFirstChild("Highlight")
            if not (ESPConfig.HighlightMurderer or ESPConfig.HighlightInnocent or ESPConfig.HighlightSheriff) then
                if highlight then
                    highlight:Destroy()
                end
                return
            end
            
            local shouldHighlight = false
            local color = Color3.new(0, 1, 0)
            if player.Name == Murder and IsAlive(player) and ESPConfig.HighlightMurderer then
                color = Color3.fromRGB(255, 0, 0)
                shouldHighlight = true
            elseif player.Name == Sheriff and IsAlive(player) and ESPConfig.HighlightSheriff then
                color = Color3.fromRGB(0, 0, 255)
                shouldHighlight = true
            elseif ESPConfig.HighlightInnocent and IsAlive(player) and 
                   player.Name ~= Murder and player.Name ~= Sheriff and player.Name ~= Hero then
                color = Color3.fromRGB(0, 255, 0)
                shouldHighlight = true
            elseif player.Name == Hero and IsAlive(player) and not IsAlive(game.Players[Sheriff]) and ESPConfig.HighlightSheriff then
                color = Color3.fromRGB(255, 250, 0)
                shouldHighlight = true
            end
            
            if shouldHighlight then
                highlight = CreateHighlight(player)
                if highlight then
                    highlight.FillColor = color
                    highlight.OutlineColor = color
                    highlight.Enabled = true
                end
            elseif highlight then
                highlight.Enabled = false
            end
        end
    end
end

function IsAlive(player)
    for name, data in pairs(roles) do
        if player.Name == name then
            return not data.Killed and not data.Dead
        end
    end
    return false
end

local function UpdateRoles()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for name, data in pairs(roles) do
        if data.Role == "Murderer" then
            Murder = name
        elseif data.Role == 'Sheriff' then
            Sheriff = name
        elseif data.Role == 'Hero' then
            Hero = name
        end
    end
end

Tabs.EspTab:Section({Title = gradient("Special ESP", Color3.fromHex("#b914fa"), Color3.fromHex("#7023c2"))})

Tabs.EspTab:Toggle({
    Title = gradient("Higlight Murder", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),
    Default = false,
    Callback = function(state) 
        ESPConfig.HighlightMurderer = state
        if not state then UpdateHighlights() end
    end
})

Tabs.EspTab:Toggle({
    Title = gradient("Highlight Innocent", Color3.fromHex("#0ff707"), Color3.fromHex("#1e690c")),
    Default = false,
    Callback = function(state) 
        ESPConfig.HighlightInnocent = state
        if not state then UpdateHighlights() end
    end
})

Tabs.EspTab:Toggle({
    Title = gradient("Highlight Sheriff", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Default = false,
    Callback = function(state) 
        ESPConfig.HighlightSheriff = state
        if not state then UpdateHighlights() end
    end
})

local gunDropESPEnabled = false
local gunDropHighlight = nil

-- Список всех возможных карт
local mapPaths = {
    "ResearchFacility", "Hospital3", "MilBase", "House2", 
    "Workplace", "Mansion2", "BioLab", "Hotel", 
    "Factory", "Bank2", "PoliceStation"
}

-- Функция создания подсветки для GunDrop
local function createGunDropHighlight(gunDrop)
    if gunDropESPEnabled and gunDrop and not gunDrop:FindFirstChild("GunDropHighlight") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "GunDropHighlight"
        highlight.FillColor = Color3.fromRGB(255, 215, 0) -- Золотой цвет
        highlight.OutlineColor = Color3.fromRGB(255, 165, 0)
        highlight.Adornee = gunDrop
        highlight.Parent = gunDrop
    end
end

-- Функция обновления ESP
local function updateGunDropESP()
    -- Удаляем старые подсветки
    for _, mapName in pairs(mapPaths) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            local gunDrop = map:FindFirstChild("GunDrop")
            if gunDrop and gunDrop:FindFirstChild("GunDropHighlight") then
                gunDrop.GunDropHighlight:Destroy()
            end
        end
    end

    -- Создаем новые подсветки если ESP включен
    if gunDropESPEnabled then
        for _, mapName in pairs(mapPaths) do
            local map = workspace:FindFirstChild(mapName)
            if map then
                local gunDrop = map:FindFirstChild("GunDrop")
                if gunDrop then
                    createGunDropHighlight(gunDrop)
                end
            end
        end
    end
end

-- Мониторинг появления GunDrop на всех картах
local function monitorGunDrops()
    for _, mapName in pairs(mapPaths) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            map.ChildAdded:Connect(function(child)
                if child.Name == "GunDrop" then
                    createGunDropHighlight(child)
                end
            end)
        end
    end
end

monitorGunDrops()

Tabs.EspTab:Toggle({
    Title = gradient("GunDrop Highlight", Color3.fromHex("#ffff00"), Color3.fromHex("#4f4f00")),
    Default = false,
    Callback = function(state)
        gunDropESPEnabled = state
        updateGunDropESP()
    end
})

-- Автоматическое обновление при смене карты
workspace.ChildAdded:Connect(function(child)
    if table.find(mapPaths, child.Name) then
        task.wait(2) -- Ждем загрузку карты
        updateGunDropESP()
    end
end)

RunService.RenderStepped:Connect(function()
    UpdateRoles()
    if ESPConfig.HighlightMurderer or ESPConfig.HighlightInnocent or ESPConfig.HighlightSheriff then
        UpdateHighlights()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if player == LP then
        RemoveAllHighlights()
    end
end)

-- Teleport
Tabs.TeleportTab:Section({Title = gradient("Default TP", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))})

local teleportTarget = nil
local teleportDropdown = nil

local function updateTeleportPlayers()
    local playersList = {"Select Player"}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playersList, player.Name)
        end
    end
    return playersList
end

local function initializeTeleportDropdown()
    teleportDropdown = Tabs.TeleportTab:Dropdown({
        Title = "Players",
        Values = updateTeleportPlayers(),
        Value = "Select Player",
        Callback = function(selected)
            if selected ~= "Select Player" then
                teleportTarget = Players:FindFirstChild(selected)
            else
                teleportTarget = nil
            end
        end
    })
end

-- Вместо старого кода инициализации телепорта вызываем:
initializeTeleportDropdown()

-- Обновляем обработчики событий игроков:
Players.PlayerAdded:Connect(function(player)
    task.wait(1) -- Даем время на инициализацию игрока
    if teleportDropdown then
        teleportDropdown:Refresh(updateTeleportPlayers())
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if teleportDropdown then
        teleportDropdown:Refresh(updateTeleportPlayers())
    end
end)

local function teleportToPlayer()
    if teleportTarget and teleportTarget.Character then
        local targetRoot = teleportTarget.Character:FindFirstChild("HumanoidRootPart")
        local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if targetRoot and localRoot then
            localRoot.CFrame = targetRoot.CFrame
            WindUI:Notify({
                Title = "Телепортация",
                Content = "Успешно телепортирован к "..teleportTarget.Name,
                Icon = "check-circle",
                Duration = 3
            })
        end
    else
        WindUI:Notify({
            Title = "Ошибка",
            Content = "Цель не найдена или недоступна",
            Icon = "x-circle",
            Duration = 3
        })
    end
end

Tabs.TeleportTab:Button({
    Title = "Teleport to player",
    Callback = teleportToPlayer
})

Tabs.TeleportTab:Button({
    Title = "Update players list",
    Callback = function()
        teleportDropdown:Refresh(updateTeleportPlayers())
    end
})

Tabs.TeleportTab:Section({Title = gradient("Special TP", Color3.fromHex("#b914fa"), Color3.fromHex("#7023c2"))})

Tabs.TeleportTab:Button({
    Title = "Teleport to Sheriff",
    Callback = function()
        UpdateRoles()
        if Sheriff then
            local sheriffPlayer = Players:FindFirstChild(Sheriff)
            if sheriffPlayer and sheriffPlayer.Character then
                local targetRoot = sheriffPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetRoot and localRoot then
                    localRoot.CFrame = targetRoot.CFrame
                    WindUI:Notify({
                        Title = "Телепортация",
                        Content = "Успешно телепортирован к шерифу "..Sheriff,
                        Icon = "check-circle",
                        Duration = 3
                    })
                end
            else
                WindUI:Notify({
                    Title = "Ошибка",
                    Content = "Шериф не найден или недоступен",
                    Icon = "x-circle",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Ошибка",
                Content = "Шериф не определен в текущем матче",
                Icon = "x-circle",
                Duration = 3
            })
        end
    end
})

Tabs.TeleportTab:Button({
    Title = "Teleport to Murderer",
    Callback = function()
        UpdateRoles()
        if Murder then
            local murderPlayer = Players:FindFirstChild(Murder)
            if murderPlayer and murderPlayer.Character then
                local targetRoot = murderPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetRoot and localRoot then
                    localRoot.CFrame = targetRoot.CFrame
                    WindUI:Notify({
                        Title = "Телепортация",
                        Content = "Успешно телепортирован к убийце "..Murder,
                        Icon = "check-circle",
                        Duration = 3
                    })
                end
            else
                WindUI:Notify({
                    Title = "Ошибка",
                    Content = "Убийца не найден или недоступен",
                    Icon = "x-circle",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Ошибка",
                Content = "Убийца не определен в текущем матче",
                Icon = "x-circle",
                Duration = 3
            })
        end
    end
})

Players.PlayerAdded:Connect(function()
    teleportDropdown:Refresh({updateTeleportPlayers()})
end)

Players.PlayerRemoving:Connect(function()
    teleportDropdown:Refresh({updateTeleportPlayers()})
end)

-- Aimbot
local roles = {}
local Murder, Sheriff
local isCameraLocked = false
local isSpectating = false
local lockedRole = nil
local cameraConnection = nil
local originalCameraType = Enum.CameraType.Custom
local originalCameraSubject = nil

function IsAlive(player)
    for name, data in pairs(roles) do
        if player.Name == name then
            return not data.Killed and not data.Dead
        end
    end
    return false
end

local function UpdateRoles()
    local success, result = pcall(function()
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    end)
    if success then
        roles = result or {}
        Murder, Sheriff = nil, nil
        for name, data in pairs(roles) do
            if data.Role == "Murderer" then Murder = name
            elseif data.Role == 'Sheriff' then Sheriff = name end
        end
    end
end

Tabs.AimbotTab:Section({Title = gradient("Default AimBot", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))})

RoleDropdown = Tabs.AimbotTab:Dropdown({
    Title = "Target Role",
    Values = {"None", "Sheriff", "Murderer"},
    Value = "None",
    Callback = function(selected)
        lockedRole = (selected ~= "None") and selected or nil
    end
})

Tabs.AimbotTab:Toggle({
    Title = "Spectate Mode",
    Default = false,
    Callback = function(state)
        isSpectating = state
        if state then
            originalCameraType = CurrentCamera.CameraType
            originalCameraSubject = CurrentCamera.CameraSubject
            CurrentCamera.CameraType = Enum.CameraType.Scriptable
        else
            CurrentCamera.CameraType = originalCameraType
            CurrentCamera.CameraSubject = originalCameraSubject
        end
    end
})

Tabs.AimbotTab:Toggle({
    Title = "Lock Camera",
    Default = false,
    Callback = function(state)
        isCameraLocked = state
        if not state and not isSpectating then
            CurrentCamera.CameraType = originalCameraType
            CurrentCamera.CameraSubject = originalCameraSubject
        end
    end
})

local function GetTargetPosition()
    if not lockedRole then return nil end
    local targetName = lockedRole == "Sheriff" and Sheriff or Murder
    if not targetName then return nil end
    local player = Players:FindFirstChild(targetName)
    if not player or not IsAlive(player) then return nil end
    local character = player.Character
    if not character then return nil end
    local head = character:FindFirstChild("Head")
    return head and head.Position or nil
end

local function UpdateSpectate()
    if not isSpectating or not lockedRole then return end
    local targetPos = GetTargetPosition()
    if not targetPos then return end
    local offset = CFrame.new(0, 2, 8)
    local targetChar = Players:FindFirstChild(lockedRole == "Sheriff" and Sheriff or Murder).Character
    if targetChar then
        local root = targetChar:FindFirstChild("HumanoidRootPart")
        if root then
            CurrentCamera.CFrame = root.CFrame * offset
        end
    end
end

local function UpdateLockCamera()
    if not isCameraLocked or not lockedRole then return end
    local targetPos = GetTargetPosition()
    if not targetPos then return end
    local currentPos = CurrentCamera.CFrame.Position
    CurrentCamera.CFrame = CFrame.new(currentPos, targetPos)
end

local function Update()
    if isSpectating then
        UpdateSpectate()
    elseif isCameraLocked then
        UpdateLockCamera()
    end
end

local function AutoUpdate()
    while true do
        UpdateRoles()
        task.wait(3)
    end
end

coroutine.wrap(AutoUpdate)()
cameraConnection = RunService.RenderStepped:Connect(Update)

LocalPlayer.AncestryChanged:Connect(function()
    if not LocalPlayer.Parent and cameraConnection then
        cameraConnection:Disconnect()
        CurrentCamera.CameraType = originalCameraType
        CurrentCamera.CameraSubject = originalCameraSubject
    end
end)

UpdateRoles()

Tabs.AimbotTab:Section({Title = gradient("Silent Aimbot (On rework)", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))})
-- Gun System Configuration
local GunSystem = {
    AutoGrabEnabled = false,
    NotifyGunDrop = true,
    GunDropCheckInterval = 1,
    ActiveGunDrops = {},
    GunDropHighlights = {}
}

-- Список всех карт
local mapPaths = {
    "ResearchFacility", "Hospital3", "MilBase", "House2", 
    "Workplace", "Mansion2", "BioLab", "Hotel", 
    "Factory", "Bank2", "PoliceStation"
}

local function InstantShootSequence()
    -- 1. Получаем данные об убийце
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    local murderer = nil
    
    for name, data in pairs(roles) do
        if data.Role == "Murderer" then
            murderer = Players:FindFirstChild(name)
            break
        end
    end
    
    -- Проверка убийцы
    if not murderer or not murderer.Character then
        WindUI:Notify({Title = "Ошибка", Content = "Убийца не найден!", Icon = "x-circle", Duration = 1})
        return
    end

    -- 2. Мгновенная экипировка (если нужно)
    local gun = LocalPlayer.Character:FindFirstChild("Gun") or LocalPlayer.Backpack:FindFirstChild("Gun")
    if not gun and selectedSheriffShootVariant:find("Equip") then
        WindUI:Notify({Title = "Ошибка", Content = "Нет оружия!", Icon = "x-circle", Duration = 1})
        return
    end
    
    if gun and not LocalPlayer.Character:FindFirstChild("Gun") then
        gun.Parent = LocalPlayer.Character
    end

    -- 3. Телепорт (если выбран режим с ТП)
    if selectedSheriffShootVariant:find("Tp") then
        local targetPos = murderer.Character:FindFirstChild("HumanoidRootPart").CFrame
        LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame = targetPos * CFrame.new(0, 0, -4)
    end

    -- 4. Мгновенный выстрел
    local gun = LocalPlayer.Character:FindFirstChild("Gun")
    if gun and gun:FindFirstChild("KnifeLocal") then
        local targetPart = murderer.Character:FindFirstChild("Head") or murderer.Character:FindFirstChild("HumanoidRootPart")
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(1, targetPart.Position, "AH2")
    end
end

-- Функция телепорта к убийце
local function TeleportToMurderer(murderer)
    local targetRoot = murderer.Character:FindFirstChild("HumanoidRootPart")
    local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if targetRoot and localRoot then
        localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -5) -- Телепорт на 5 метров перед убийцей
        task.wait(0.3) -- Даем время на телепорт
        return true
    end
    return false
end

-- Основная функция вариативной стрельбы
local function VariableShootMurderer()
    -- Получаем данные об убийце
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    local murderer = nil
    
    for name, data in pairs(roles) do
        if data.Role == "Murderer" then
            murderer = Players:FindFirstChild(name)
            break
        end
    end
    
    -- Проверка убийцы
    if not murderer or not murderer.Character then
        WindUI:Notify({
            Title = "Gun System",
            Content = "Murder not found!",
            Icon = "x-circle",
            Duration = 3
        })
        return
    end

    -- Обработка выбранного варианта
    if selectedSheriffShootVariant == "Equip + Shoot" or selectedSheriffShootVariant == "Tp + Equip + Shoot" then
        if not EquipGun() then
            WindUI:Notify({
                Title = "Gub System",
                Content = "Gun not found in backpack",
                Icon = "x-circle",
                Duration = 3
            })
            return
        end
    end

    if selectedSheriffShootVariant == "Tp + Shoot" or selectedSheriffShootVariant == "Tp + Equip + Shoot" then
        if not TeleportToMurderer(murderer) then
            WindUI:Notify({
                Title = "Gun System",
                Content = "Failed to teleport!",
                Icon = "x-circle",
                Duration = 3
            })
            return
        end
    end

    -- Проверка оружия в руках
    local gun = LocalPlayer.Character:FindFirstChild("Gun")
    if not gun then
        WindUI:Notify({
            Title = "Gun System",
            Content = "Gun not equipped",
            Icon = "x-circle",
            Duration = 3
        })
        return
    end

    -- Точный выстрел в HumanoidRootPart
    local targetPart = murderer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local args = {
        [1] = 1,
        [2] = targetPart.Position, -- Точная позиция без предсказаний
        [3] = "AH2"
    }
    
    if gun:FindFirstChild("KnifeLocal") and gun.KnifeLocal:FindFirstChild("CreateBeam") then
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
        WindUI:Notify({
            Title = "Shot",
            Content = "Mode: "..selectedSheriffShootVariant.." - Success!",
            Icon = "check-circle",
            Duration = 3
        })
    end
end

-- Функция сканирования GunDrop
local function ScanForGunDrops()
    GunSystem.ActiveGunDrops = {}
    
    -- Проверяем все карты
    for _, mapName in ipairs(mapPaths) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            local gunDrop = map:FindFirstChild("GunDrop")
            if gunDrop then
                table.insert(GunSystem.ActiveGunDrops, gunDrop)
            end
        end
    end
    
    -- Проверяем корневой workspace
    local rootGunDrop = workspace:FindFirstChild("GunDrop")
    if rootGunDrop then
        table.insert(GunSystem.ActiveGunDrops, rootGunDrop)
    end
end

-- Функция GrabGun
local function GrabGun(gunDrop)
    if not gunDrop then
        -- Если GunDrop не указан, ищем ближайший
        ScanForGunDrops()
        if #GunSystem.ActiveGunDrops == 0 then
            WindUI:Notify({
                Title = "Gun System",
                Content = "No guns available on the map",
                Icon = "x-circle",
                Duration = 3
            })
            return false
        end
        
        -- Находим ближайший GunDrop
        local nearestGun = nil
        local minDistance = math.huge
        local character = LocalPlayer.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        
        if humanoidRootPart then
            for _, drop in ipairs(GunSystem.ActiveGunDrops) do
                local distance = (humanoidRootPart.Position - drop.Position).Magnitude
                if distance < minDistance then
                    nearestGun = drop
                    minDistance = distance
                end
            end
        end
        
        gunDrop = nearestGun
    end

    -- Телепортируемся и подбираем оружие
    if gunDrop and LocalPlayer.Character then
        local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.CFrame = gunDrop.CFrame
            task.wait(0.3)
            
            local prompt = gunDrop:FindFirstChildOfClass("ProximityPrompt")
            if prompt then
                fireproximityprompt(prompt)
                WindUI:Notify({
                    Title = "Gun System",
                    Content = "Successfully grabbed the gun!",
                    Icon = "check-circle",
                    Duration = 3
                })
                return true
            end
        end
    end
    
    return false
end

-- Функция AutoGrabGun
local function AutoGrabGun()
    while GunSystem.AutoGrabEnabled do
        ScanForGunDrops()
        
        if #GunSystem.ActiveGunDrops > 0 and LocalPlayer.Character then
            local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Находим ближайший GunDrop
                local nearestGun = nil
                local minDistance = math.huge
                
                for _, gunDrop in ipairs(GunSystem.ActiveGunDrops) do
                    local distance = (humanoidRootPart.Position - gunDrop.Position).Magnitude
                    if distance < minDistance then
                        nearestGun = gunDrop
                        minDistance = distance
                    end
                end
                
                -- Телепортируемся и подбираем
                if nearestGun then
                    humanoidRootPart.CFrame = nearestGun.CFrame
                    task.wait(0.3)
                    
                    local prompt = nearestGun:FindFirstChildOfClass("ProximityPrompt")
                    if prompt then
                        fireproximityprompt(prompt)
                        task.wait(1) -- Задержка перед следующей проверкой
                    end
                end
            end
        end
        
        task.wait(GunSystem.GunDropCheckInterval)
    end
end

local function GetMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData"):InvokeServer()
    for playerName, data in pairs(roles) do
        if data.Role == "Murderer" then
            return Players:FindFirstChild(playerName)
        end
    end
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function ShootMurderer()
    -- 1. Проверка экипировки оружия
    if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Gun")) then
        if not LocalPlayer.Backpack:FindFirstChild("Gun") then
            WindUI:Notify({
                Title = "ОШИБКА",
                Content = "Gun не найден в инвентаре!",
                Icon = "x-circle",
                Duration = 3
            })
            return false
        else
            -- Авто-экипировка если Gun в рюкзаке
            LocalPlayer.Backpack.Gun.Parent = LocalPlayer.Character
            task.wait(0.2)
        end
    end

    -- 2. Поиск убийцы с кешированием ролей
    local murderer
    local success, roles = pcall(function()
        return ReplicatedStorage:FindFirstChild("GetPlayerData"):InvokeServer()
    end)
    
    if success and roles then
        for name, data in pairs(roles) do
            if data.Role == "Murderer" then
                murderer = Players:FindFirstChild(name)
                break
            end
        end
    end

    if not (murderer and murderer.Character and murderer.Character:FindFirstChild("Humanoid")) then
        WindUI:Notify({
            Title = "ОШИБКА",
            Content = "Убийца не найден!",
            Icon = "x-circle",
            Duration = 3
        })
        return false
    end

    -- 3. Выбор оптимальной части тела
    local targetPart = murderer.Character:FindFirstChild("Head") 
                     or murderer.Character:FindFirstChild("HumanoidRootPart")
                     or murderer.Character:FindFirstChild("UpperTorso")

    if not targetPart then
        WindUI:Notify({
            Title = "ОШИБКА",
            Content = "Не найдена цель для выстрела!",
            Icon = "x-circle",
            Duration = 3
        })
        return false
    end

    -- 4. Безопасный вызов RemoteFunction
    local gun = LocalPlayer.Character.Gun
    if gun and gun:FindFirstChild("KnifeLocal") then
        local remote = gun.KnifeLocal:FindFirstChild("CreateBeam")
        if remote and remote:IsA("RemoteFunction") then
            local args = {
                [1] = 1, -- Тип выстрела
                [2] = targetPart.Position,
                [3] = "AH2" -- Анимация
            }
            
            local shotSuccess = pcall(function()
                remote:InvokeServer(unpack(args))
            end)
            
            if shotSuccess then
                WindUI:Notify({
                    Title = "Success!",
                    Content = "Shooted: "..murderer.Name.."!",
                    Icon = "check-circle",
                    Duration = 2
                })
                return true
            end
        end
    end

    WindUI:Notify({
        Title = "Gun System",
        Content = "Error shot",
        Icon = "x-circle",
        Duration = 3
    })
    return false
end

local function GrabAndShootMurderer()
    if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Gun")) then
        if not GrabGun() then
            WindUI:Notify({
                Title = "Gun System",
                Content = "Failed to get gun!",
                Icon = "x-circle",
                Duration = 3
            })
            return
        end
        task.wait(0.5) -- Даем время на подбор
    end

    -- Экипируем оружие (на всякий случай)
    if not EquipGun() then
        WindUI:Notify({
            Title = "Gun System",
            Content = "Failed to equip gun!",
            Icon = "x-circle",
            Duration = 3
        })
        return
    end

    -- Получаем данные об убийце
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    local murderer = nil
    
    for name, data in pairs(roles) do
        if data.Role == "Murderer" then
            murderer = Players:FindFirstChild(name)
            break
        end
    end
    
    -- Проверка убийцы
    if not murderer or not murderer.Character then
        WindUI:Notify({
            Title = "Gun System",
            Content = "Murderer not found!",
            Icon = "x-circle",
            Duration = 3
        })
        return
    end

    -- Телепортируемся ближе к убийце
    local targetRoot = murderer.Character:FindFirstChild("HumanoidRootPart")
    local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if targetRoot and localRoot then
        localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -4) -- Телепорт на 4 метра перед убийцей
        task.wait(0.3) -- Даем время на телепорт
    end

    -- Проверяем оружие в руках
    local gun = LocalPlayer.Character:FindFirstChild("Gun")
    if not gun then
        WindUI:Notify({
            Title = "Gun System",
            Content = "Gun not equipped!",
            Icon = "x-circle",
            Duration = 3
        })
        return
    end

    -- Точный выстрел в HumanoidRootPart
    local targetPart = murderer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local args = {
        [1] = 1,
        [2] = targetPart.Position,
        [3] = "AH2"
    }
    
    if gun:FindFirstChild("KnifeLocal") and gun.KnifeLocal:FindFirstChild("CreateBeam") then
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
        WindUI:Notify({
            Title = "Gun System",
            Content = "Successfully shot the murderer!",
            Icon = "check-circle",
            Duration = 3
        })
    end
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Функция экипировки Gun (оптимизированная)
local function EquipGun()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Gun") then
        return true
    end

    local gun = LocalPlayer.Backpack:FindFirstChild("Gun")
    if gun then
        gun.Parent = LocalPlayer.Character
        task.wait(0.1)
        return LocalPlayer.Character:FindFirstChild("Gun") ~= nil
    end
    return false
end

-- GunDrop Notification System
local gunDropESPEnabled = true -- По умолчанию включено
local notifiedGunDrops = {} -- Таблица для отслеживания уже оповещенных GunDrop

-- Список всех карт и их GunDrop
local mapGunDrops = {
    "ResearchFacility",
    "Hospital3",
    "MilBase",
    "House2",
    "Workplace",
    "Mansion2",
    "BioLab",
    "Hotel",
    "Factory",
    "Bank2",
    "PoliceStation"
}

-- Функция проверки GunDrop на всех картах
local function checkForGunDrops()
    for _, mapName in ipairs(mapGunDrops) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            local gunDrop = map:FindFirstChild("GunDrop")
            if gunDrop and not notifiedGunDrops[gunDrop] then
                -- Если GunDrop найден и еще не было уведомления
                if gunDropESPEnabled then
                    WindUI:Notify({
                        Title = "Gun Drop Spawned",
                        Content = "A gun has appeared on the map: "..mapName,
                        Icon = "alert-circle",
                        Duration = 5
                    })
                end
                notifiedGunDrops[gunDrop] = true -- Помечаем как оповещенный
            end
        end
    end
end

-- Мониторинг появления новых GunDrop
local function setupGunDropMonitoring()
    for _, mapName in ipairs(mapGunDrops) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            -- Обработка уже существующих GunDrop
            if map:FindFirstChild("GunDrop") then
                checkForGunDrops()
            end
            
            -- Отслеживание появления новых GunDrop
            map.ChildAdded:Connect(function(child)
                if child.Name == "GunDrop" then
                    task.wait(0.5) -- Небольшая задержка для стабильности
                    checkForGunDrops()
                end
            end)
        end
    end
end

-- Очистка уведомлений при удалении GunDrop
local function setupGunDropRemovalTracking()
    for _, mapName in ipairs(mapGunDrops) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            map.ChildRemoved:Connect(function(child)
                if child.Name == "GunDrop" and notifiedGunDrops[child] then
                    notifiedGunDrops[child] = nil -- Удаляем из списка при исчезновении
                end
            end)
        end
    end
end

-- Инициализация системы
setupGunDropMonitoring()
setupGunDropRemovalTracking()

-- Добавляем проверку при смене карты
workspace.ChildAdded:Connect(function(child)
    if table.find(mapGunDrops, child.Name) then
        task.wait(2) -- Ждем загрузку карты
        checkForGunDrops()
    end
end)

-- Добавляем в UI (заменяем старый Toggle)
Tabs.InnocentTab:Toggle({
    Title = "Notify GunDrop",
    Default = true,
    Callback = function(state)
        gunDropESPEnabled = state
        if state then
            -- При включении сразу проверяем наличие GunDrop
            task.spawn(function()
                task.wait(1)
                checkForGunDrops()
            end)
        end
    end
})

-- UI Elements
Tabs.InnocentTab:Button({
    Title = "Grab Gun",
    Callback = function()
        GrabGun()
    end
})

Tabs.InnocentTab:Toggle({
    Title = "Auto Grab Gun",
    Default = false,
    Callback = function(state)
        GunSystem.AutoGrabEnabled = state
        if state then
            coroutine.wrap(AutoGrabGun)()
            WindUI:Notify({
                Title = "Gun System",
                Content = "Auto Grab Gun enabled!",
                Icon = "check-circle",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Gun System",
                Content = "Auto Grab Gun disabled",
                Icon = "check-circle",
                Duration = 3
            })
        end
    end
})

Tabs.InnocentTab:Button({
    Title = "Grab Gun & Shoot Murderer",
    Callback = function()
        GrabAndShootMurderer()
    end
})

-- Инициализация при запуске
task.spawn(function()
    -- Ждем загрузку игрока
    if not LocalPlayer.Character then
        LocalPlayer.CharacterAdded:Wait()
    end
    
    -- Запускаем мониторинг GunDrop
    ScanForGunDrops()
    
    -- Если AutoGrab уже включен, запускаем
    if GunSystem.AutoGrabEnabled then
        coroutine.wrap(AutoGrabGun)()
    end
end)


-- Murder Tab
Tabs.MurderTab:Section({Title = gradient("Kill Functions", Color3.fromHex("#e80909"), Color3.fromHex("#630404"))})

-- Sheriff Tab
Tabs.SheriffTab:Section({Title = gradient("Shoot Functions", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9"))})

-- Dropdown для выбора варианта
Tabs.SheriffTab:Dropdown({
    Title = "Shoot Variant",
    Values = sheriffShootVariants,
    Value = selectedSheriffShootVariant,
    Callback = function(value)
        selectedSheriffShootVariant = value
    end
})

Tabs.SheriffTab:Button({
    Title = "Shoot Murderer",
    Callback = function()
        InstantShootSequence()
    end
})

Tabs.SheriffTab:Toggle({
    Title = "Auto Shoot Murderer",
    Default = false,
    Callback = function(state)
        
    end
})

-- Запускаем только после полной загрузки UI
task.spawn(function()
    -- Ждем, пока игрок загрузится
    if not LocalPlayer.Character then
        LocalPlayer.CharacterAdded:Wait()
    end

    -- Ожидаем загрузку карты
    while not workspace:FindFirstChildOfClass("Model") do
        task.wait(1)
    end

    -- Защищенный вызов функций
    pcall(function()
        scanForGunDrops()
        monitorNewGunDrops()
    end)

    -- Запускаем авто-подбор в фоне
    if config.AutoGrabGun then
        coroutine.wrap(autoGrabLoop)()
    end
end)

-- Settings
local Settings = {
    Hitbox = {
        Enabled = false,
        Size = 5,
        Color = Color3.new(1,0,0),
        Adornments = {},
        Connections = {}
    },
    Noclip = {
        Enabled = false,
        Connection = nil
    },
    AntiAFK = {
        Enabled = false,
        Connection = nil
    }
}

local function ToggleNoclip(state)
        if state then
            Settings.Noclip.Connection = RunService.Stepped:Connect(function()
                local chr = LocalPlayer.Character
                if chr then
                    for _, part in pairs(chr:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
                end)
        else
            if Settings.Noclip.Connection then
                Settings.Noclip.Connection:Disconnect()
            end
        end
end

local function UpdateHitboxes()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local chr = plr.Character
                local box = Settings.Hitbox.Adornments[plr]
                
                if chr and Settings.Hitbox.Enabled then
                    local root = chr:FindFirstChild("HumanoidRootPart")
                    if root then
                        if not box then
                            box = Instance.new("BoxHandleAdornment")
                            box.Adornee = root
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                            box.Transparency = 0.4
                            box.ZIndex = 10
                            box.Parent = root
                            Settings.Hitbox.Adornments[plr] = box
                        else
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                        end
                    end
                elseif box then
                    box:Destroy()
                    Settings.Hitbox.Adornments[plr] = nil
                end
            end
        end
end

local function ToggleAntiAFK(state)
        if state then
            Settings.AntiAFK.Connection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
                end)
            end)
        else
            if Settings.AntiAFK.Connection then
                Settings.AntiAFK.Connection:Disconnect()
            end
        end
end

Tabs.SettingsTab:Section({
    Title = gradient("Hitboxes", Color3.fromHex("#ff0000"), Color3.fromHex("#ff8800"))
})

Tabs.SettingsTab:Toggle({
    Title = "Hitboxes",
    Callback = function(state)
        Settings.Hitbox.Enabled = state
        if state then
            RunService.Heartbeat:Connect(UpdateHitboxes)
        else
            for _, box in pairs(Settings.Hitbox.Adornments) do
                if box then box:Destroy() end
            end
            Settings.Hitbox.Adornments = {}
        end
    end
})

Tabs.SettingsTab:Slider({
    Title = "Hitbox size",
    Value = {Min=1, Max=10, Default=5},
    Callback = function(val)
        Settings.Hitbox.Size = val
        UpdateHitboxes()
    end
})

Tabs.SettingsTab:Colorpicker({
    Title = "Hitbox color",
    Default = Color3.new(1,0,0),
    Callback = function(col)
        Settings.Hitbox.Color = col
        UpdateHitboxes()
    end
})

Tabs.SettingsTab:Section({
    Title = gradient("Character Functions", Color3.fromHex("#00eaff"), Color3.fromHex("#002a2e"))
})


Tabs.SettingsTab:Toggle({
    Title = "Anti-AFK",
    Callback = function(state)
        Settings.AntiAFK.Enabled = state
        ToggleAntiAFK(state)
    end
})

Tabs.SettingsTab:Toggle({
    Title = "NoClip",
    Callback = function(state)
        Settings.Noclip.Enabled = state
        ToggleNoclip(state)
    end
})

-- Auto Exec

Tabs.SettingsTab:Section({
    Title = gradient("Auto Execute", Color3.fromHex("#00ff40"), Color3.fromHex("#88f2a2"))
})

local AutoInject = {
    Enabled = false,
    ScriptURL = "https://raw.githubusercontent.com/Snowt-Team/SNT-HUB/refs/heads/main/MM2.txt"
}

Tabs.SettingsTab:Toggle({
    Title = "Auto Inject on Rejoin/Hop",
    Default = false,
    Callback = function(state)
        AutoInject.Enabled = state
        if state then
            SetupAutoInject()
            WindUI:Notify({
                Title = "Auto Inject",
                Content = "Автоинжект включен! Скрипт перезапустится автоматически.",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Auto Inject",
                Content = "Автоинжект отключен",
                Duration = 3
            })
        end
    end
})

local function SetupAutoInject()
    if not AutoInject.Enabled then return end
    
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    spawn(function()
        wait(2)
        if AutoInject.Enabled then
            pcall(function()
                loadstring(game:HttpGet(AutoInject.ScriptURL))()
            end)
        end
    end)

    LocalPlayer.OnTeleport:Connect(function(state)
        if state == Enum.TeleportState.Started and AutoInject.Enabled then
            queue_on_teleport([[
                wait(2)
                loadstring(game:HttpGet("]]..AutoInject.ScriptURL..[["))()
            ]])
        end
    end)

    game:GetService("Players").PlayerRemoving:Connect(function(player)
        if player == LocalPlayer and AutoInject.Enabled then
            queue_on_teleport([[
                wait(2)
                loadstring(game:HttpGet("]]..AutoInject.ScriptURL..[["))()
            ]])
        end
    end)
end

Tabs.SettingsTab:Button({
    Title = "Manual Re-Inject",
    Callback = function()
        pcall(function()
            loadstring(game:HttpGet(AutoInject.ScriptURL))()
            WindUI:Notify({
                Title = "Manual Inject",
                Content = "Скрипт успешно перезагружен!",
                Duration = 3
            })
        end)
    end
})

-- Socials
Tabs.SocialsTab:Paragraph({
    Title = gradient("SnowT", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Desc = "My socials",
    Image = "bird",
    Color = "Green",
    Buttons = {
        { Icon = "circle",
          Title = "TG Channel",
          Callback = function()
              SetClipboard("t.me/supreme_scripts") end,
        }
    }
})

Tabs.SocialsTab:Paragraph({
    Title = gradient("Mirrozz", Color3.fromHex("#ffffff"), Color3.fromHex("#363636")),
    Desc = "Socials My Friend",
    Image = "bird",
    Color = "Green",
    Buttons = {
        {
            Title = "TG Channel",
            Icon = "circle",
            Callback = function() SetClipboard("t.me/mirrozzscript")
    end,
        }
    }
})

-- Changelogs
Tabs.ChangelogsTab:Code({
    Title = "Changelogs:",
    Code = [[
    Official Release! Changelogs last update:
    • Official release
    • New Design
    • New Tabs [Innocent; Murder; Sheriff]
    • Removed Silent Aimbot (Broken)
    • Rework All Sheriff Functions
    |• Better shot
    |• Fixed errors
    |• New shot variants [shoot; equip + shoot; tp + shoot; equip + tp + shoot]
    |• Faster shots
    • Rework All Murder Functions
    |• Fixed kill player
    |• Kill player variants [Hit; Tp + Hit; Equip + Tp + Hit (Instant Hit)]
    • Rework All Innocent Functions
    |• Fixed Grab GunDrop (Fixed Invalid Position error)
    |• Fixed Auto Grab Gun Drop (Tp every 1 second and constant verification)
    |• New grab gun and shoot murder function
    • Rework Notify GunDrop
    |• Fixed Notifications (1 notification when a gundrop spawned, instead of spam notifications)
    |• Fixed Check GunDrop Function (More stability, No Bags)
    • New autofarm functions (Autofarm coins)
    • Fixed Esp
    • Tp to lobby function
   More functions will be added in future!
]]
})

Tabs.ChangelogsTab:Code({
    Title = "Next update:",
    Code = [[ The next update is [v1.1]
    In future we will be add:
    • Kill all function (Murder)
    • Event autofarm (eggs)
    • Autofarm rare eggs
    • Fix bugs
   The date of update: 25.05.2025!
]]
})

-- Server
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

Tabs.ServerTab:Button({
    Title = "Rejoin",
    Callback = function()
        local success, error = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Players.LocalPlayer)
        end)
        if not success then
            warn("Rejoin error:", error)
        end
    end
})

Tabs.ServerTab:Section({
    Title = ""
})

Tabs.ServerTab:Button({
    Title = "Server Hop",
    Callback = function()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        
        local function serverHop()
            local servers = {}
            local success, result = pcall(function()
                return HttpService:JSONDecode(HttpService:GetAsync("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
            end)
            
            if success and result and result.data then
                for _, server in ipairs(result.data) do
                    if server.id ~= currentJobId then
                        table.insert(servers, server)
                    end
                end
                
                if #servers > 0 then
                    TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(#servers)].id)
                else
                    TeleportService:Teleport(placeId)
                end
            else
                TeleportService:Teleport(placeId)
            end
        end
        
        pcall(serverHop)
    end
})

Tabs.ServerTab:Button({
    Title = "Join to Lower Server",
    Callback = function()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        
        local function joinLowerServer()
            local servers = {}
            local success, result = pcall(function()
                return HttpService:JSONDecode(HttpService:GetAsync("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
            end)
            
            if success and result and result.data then
                for _, server in ipairs(result.data) do
                    if server.id ~= currentJobId and server.playing < (server.maxPlayers or 30) then
                        table.insert(servers, server)
                    end
                end
                
                table.sort(servers, function(a, b)
                    return a.playing < b.playing
                end)
                
                if #servers > 0 then
                    TeleportService:TeleportToPlaceInstance(placeId, servers[1].id)
                else
                    TeleportService:Teleport(placeId)
                end
            else
                TeleportService:Teleport(placeId)
            end
        end
        
        pcall(joinLowerServer)
    end
})

-- Configuration
local HttpService = game:GetService("HttpService")

local folderPath = "WindUI"
makefolder(folderPath)

local function SaveFile(fileName, data)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    local jsonData = HttpService:JSONEncode(data)
    writefile(filePath, jsonData)
end

local function LoadFile(fileName)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    if isfile(filePath) then
        local jsonData = readfile(filePath)
        return HttpService:JSONDecode(jsonData)
    end
end

local function ListFiles()
    local files = {}
    for _, file in ipairs(listfiles(folderPath)) do
        local fileName = file:match("([^/]+)%.json$")
        if fileName then
            table.insert(files, fileName)
        end
    end
    return files
end

Tabs.WindowTab:Section({ Title = "Window" })
local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.WindowTab:Dropdown({
    Title = "Select Theme",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

themeDropdown:Select(WindUI:GetCurrentTheme())

local ToggleTransparency = Tabs.WindowTab:Toggle({
    Title = "Toggle Window Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = WindUI:GetTransparency()
})

Tabs.WindowTab:Section({ Title = "Save" })

local fileNameInput = ""
Tabs.WindowTab:Input({
    Title = "Write File Name",
    PlaceholderText = "Enter file name",
    Callback = function(text)
        fileNameInput = text
    end
})

Tabs.WindowTab:Button({
    Title = "Save File",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.WindowTab:Section({ Title = "Load" })

local filesDropdown
local files = ListFiles()

filesDropdown = Tabs.WindowTab:Dropdown({
    Title = "Select File",
    Multi = false,
    AllowNone = true,
    Values = files,
    Callback = function(selectedFile)
        fileNameInput = selectedFile
    end
})

Tabs.WindowTab:Button({
    Title = "Load File",
    Callback = function()
        if fileNameInput ~= "" then
            local data = LoadFile(fileNameInput)
            if data then
                WindUI:Notify({
                    Title = "File Loaded",
                    Content = "Loaded data: " .. HttpService:JSONEncode(data),
                Duration = 5,
                })
                if data.Transparent then 
                    Window:ToggleTransparency(data.Transparent)
                    ToggleTransparency:SetValue(data.Transparent)
                end
                if data.Theme then WindUI:SetTheme(data.Theme) end
            end
        end
    end
})

Tabs.WindowTab:Button({
    Title = "Overwrite File",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.WindowTab:Button({
    Title = "Refresh List",
    Callback = function()
        filesDropdown:Refresh(ListFiles())
    end
})

-- Themes
local currentThemeName = WindUI:GetCurrentTheme()
local themes = WindUI:GetThemes()

local ThemeAccent = themes[currentThemeName].Accent
local ThemeOutline = themes[currentThemeName].Outline
local ThemeText = themes[currentThemeName].Text
local ThemePlaceholderText = themes[currentThemeName].PlaceholderText

function updateTheme()
    WindUI:AddTheme({
        Name = currentThemeName,
        Accent = ThemeAccent,
        Outline = ThemeOutline,
        Text = ThemeText,
        PlaceholderText = ThemePlaceholderText
    })
    WindUI:SetTheme(currentThemeName)
end

Tabs.CreateThemeTab:Colorpicker({
    Title = "Background Color",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Outline Color",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Text Color",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color
    end
})

Tabs.CreateThemeTab:Button({
    Title = "Update Theme",
    Callback = function()
        WindUI:AddTheme({
            Name = currentThemeName,
            Accent = ThemeAccent,
            Outline = ThemeOutline,
            Text = ThemeText,
            PlaceholderText = ThemePlaceholderText
        })
        WindUI:SetTheme(currentThemeName)
        WindUI:Notify({
            Title = "Тема обновлена",
            Content = "Новая тема '"..currentThemeName.."' применена!",
            Duration = 3,
            Icon = "check-circle"
        })
    end
})