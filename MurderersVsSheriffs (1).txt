-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TextChatService = game:GetService("TextChatService")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer

-- WindUI (с fallback, если загрузка не удалась)
local WindUI
local success, err = pcall(function()
    WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not success then
    warn("Failed to load WindUI: " .. err)
    WindUI = { -- Минимальная заглушка для UI
        Notify = function(args) print("Notify: " .. args.Content) end,
        CreateWindow = function(args) 
            return {
                Tab = function() return { Section = function() end, Toggle = function() end, Slider = function() end, Colorpicker = function() end, Dropdown = function() end, Button = function() end, RefreshDropdown = function() end }
            }
        end,
        Popup = function(args) args.Buttons[2].Callback() end
    }
end

-- ESP Objects
local espObjects = {}

-- Gradient Function
local function gradient(text, startColor, endColor)
    local result = ""
    local length = #text
    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end
    return result
end

-- Confirmation Popup
local Confirmed = false
WindUI:Popup({
    Title = gradient("PRIVATE SCRIPT", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),
    Content = "Loading script...",
    Buttons = {
        { Title = "Cancel", Callback = function() end, Variant = "Tertiary" },
        { Title = "Load", Callback = function() Confirmed = true end, Variant = "Secondary" }
    }
})

repeat task.wait() until Confirmed

WindUI:Notify({ Title = "SCRIPT SYSTEM", Content = "Script loaded", Icon = "check-circle", Duration = 3 })

-- Create Window
local Window = WindUI:CreateWindow({
    Title = gradient("PRIVATE SCRIPT", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Size = UDim2.fromOffset(300, 270),
    Theme = "Dark"
})

-- Tabs
local Tabs = {
    EspTab = Window:Tab({ Title = gradient("ESP", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "eye" }),
    AimbotTab = Window:Tab({ Title = gradient("AIMBOT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "arrow-right" })
}

-- Team Detection
local function getPlayerTeam(player)
    for _, channel in pairs(TextChatService.TextChannels:GetChildren()) do
        if channel:IsA("TextChannel") then
            local playerName = string.match(channel.Name, "%.(.+)$")
            if playerName and playerName == player.Name then
                local teamName = string.match(channel.Name, "^RBXTeam(.+)%.")
                if teamName then
                    return {
                        Name = teamName,
                        TeamColor = teamName:find("Lily white") and BrickColor.new("Lily white") or BrickColor.new("Quill grey")
                    }
                end
            end
        end
    end
    return nil
end

local function isEnemy(player)
    if player == LocalPlayer then return false end
    local localTeam = getPlayerTeam(LocalPlayer)
    local playerTeam = getPlayerTeam(player)
    if not localTeam or not playerTeam then
        warn("Team not found for " .. player.Name)
        return false
    end
    return localTeam.Name ~= playerTeam.Name
end

-- ESP Settings
local espSettings = {
    Highlight = { Enabled = false, Transparency = 0.5, Color = Color3.fromRGB(255, 0, 0), TeamColor = true },
    Names = { Enabled = false, Size = 15, Color = Color3.fromRGB(255, 255, 255) },
    TeamCheck = true
}

-- ESP Implementation
local function createEsp(player)
    if player == LocalPlayer or not isEnemy(player) then return end
    
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not humanoidRootPart then return end
    
    local highlightColor = espSettings.Highlight.TeamColor and getPlayerTeam(player).TeamColor.Color or espSettings.Highlight.Color
    
    local highlight = Instance.new("Highlight")
    highlight.Name = player.Name .. "_Highlight"
    highlight.Adornee = character
    highlight.FillColor = highlightColor
    highlight.FillTransparency = espSettings.Highlight.Transparency
    highlight.OutlineColor = highlightColor
    highlight.OutlineTransparency = 0
    highlight.Parent = CoreGui
    highlight.Enabled = espSettings.Highlight.Enabled
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = player.Name .. "_Billboard"
    billboard.Adornee = humanoidRootPart
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = CoreGui
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = espSettings.Names.Color
    nameLabel.TextSize = espSettings.Names.Size
    nameLabel.Text = player.Name
    nameLabel.Visible = espSettings.Names.Enabled
    nameLabel.Parent = billboard
    
    espObjects[player] = {
        Highlight = highlight,
        Billboard = billboard,
        NameLabel = nameLabel,
        Character = character
    }
    
    coroutine.wrap(function()
        while character and character.Parent and espObjects[player] do
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                nameLabel.Text = player.Name .. " [" .. string.format("%.1f", distance) .. " studs]"
            end
            task.wait(0.1)
        end
    end)()
end

local function toggleEsp()
    for _, player in pairs(Players:GetPlayers()) do
        if espObjects[player] then
            local isEnemyPlayer = isEnemy(player)
            espObjects[player].Highlight.Enabled = espSettings.Highlight.Enabled and isEnemyPlayer
            espObjects[player].NameLabel.Visible = espSettings.Names.Enabled and isEnemyPlayer
            if isEnemyPlayer and espSettings.Highlight.TeamColor then
                local team = getPlayerTeam(player)
                if team then
                    espObjects[player].Highlight.FillColor = team.TeamColor.Color
                    espObjects[player].Highlight.OutlineColor = team.TeamColor.Color
                end
            else
                espObjects[player].Highlight.FillColor = espSettings.Highlight.Color
                espObjects[player].Highlight.OutlineColor = espSettings.Highlight.Color
            end
        elseif isEnemy(player) then
            createEsp(player)
        end
    end
end

-- Initialize ESP
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createEsp(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            createEsp(player)
        end)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if espObjects[player] then
        espObjects[player].Highlight:Destroy()
        espObjects[player].Billboard:Destroy()
        espObjects[player] = nil
    end
end)

-- ESP Tab
Tabs.EspTab:Section({ Title = gradient("ESP Settings", Color3.fromHex("#FF00FF"), Color3.fromHex("#800080")) })

Tabs.EspTab:Toggle({
    Title = "Enable Highlight",
    Default = false,
    Callback = function(state)
        espSettings.Highlight.Enabled = state
        toggleEsp()
    end
})

Tabs.EspTab:Toggle({
    Title = "Enable Names",
    Default = false,
    Callback = function(state)
        espSettings.Names.Enabled = state
        toggleEsp()
    end
})

Tabs.EspTab:Toggle({
    Title = "Use Team Colors",
    Default = true,
    Callback = function(state)
        espSettings.Highlight.TeamColor = state
        toggleEs
p()
    end
})

Tabs.EspTab:Slider({
    Title = "Highlight Transparency",
    Step = 0.1,
    Value = {Min = 0, Max = 1, Default = 0.5},
    Callback = function(value)
        espSettings.Highlight.Transparency = value
        toggleEsp()
    end
})

Tabs.EspTab:Colorpicker({
    Title = "Highlight Color",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        espSettings.Highlight.Color = color
        toggleEsp()
    end
})

-- Aimbot Settings
local aimbotSettings = {
    Enabled = false,
    LockCameraNearest = false,
    Smoothness = 5,
    TeamCheck = true
}

local silentAimSettings = {
    Enabled = false,
    HitboxSize = 9999
}

-- Aimbot Target Finding
local function findTarget()
    if not aimbotSettings.LockCameraNearest then return nil end
    
    local closestPlayer = nil
    local closestDistance = math.huge
    local camera = Workspace.CurrentCamera
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and isEnemy(player) then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                local screenPoint, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    local distance = (humanoidRootPart.Position - (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Vector3.new())).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Silent Aimbot Implementation
local function applySilentAim()
    if not silentAimSettings.Enabled then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and isEnemy(player) and player.Character then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                if not humanoidRootPart:FindFirstChild("OriginalSize") then
                    local originalSize = Instance.new("Vector3Value")
                    originalSize.Name = "OriginalSize"
                    originalSize.Value = humanoidRootPart.Size
                    originalSize.Parent = humanoidRootPart
                end
                
                humanoidRootPart.Size = Vector3.new(silentAimSettings.HitboxSize, silentAimSettings.HitboxSize, silentAimSettings.HitboxSize)
                humanoidRootPart.Transparency = 0.9
                humanoidRootPart.CanCollide = false
            end
        end
    end
end

local function restoreHitboxes()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local originalSize = humanoidRootPart:FindFirstChild("OriginalSize")
            if originalSize then
                humanoidRootPart.Size = originalSize.Value
                humanoidRootPart.Transparency = 0
                humanoidRootPart.CanCollide = true
                originalSize:Destroy()
            end
        end
    end
end

-- Aimbot Tab
Tabs.AimbotTab:Section({ Title = gradient("Aimbot Settings", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6")) })

Tabs.AimbotTab:Toggle({
    Title = "Lock Camera to Nearest Enemy",
    Default = false,
    Callback = function(state)
        aimbotSettings.LockCameraNearest = state
    end
})

Tabs.AimbotTab:Slider({
    Title = "Smoothness",
    Step = 0.1,
    Value = {Min = 1, Max = 10, Default = 5},
    Callback = function(value)
        aimbotSettings.Smoothness = value
    end
})

Tabs.AimbotTab:Section({ Title = gradient("Silent Aimbot", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6")) })

Tabs.AimbotTab:Toggle({
    Title = "Enable Silent Aimbot",
    Default = false,
    Callback = function(state)
        silentAimSettings.Enabled = state
        if not state then
            restoreHitboxes()
        end
    end
})

-- Aimbot Loop
RunService.RenderStepped:Connect(function()
    if aimbotSettings.LockCameraNearest then
        local target = findTarget()
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local targetPos = target.Character.HumanoidRootPart.Position
            local camera = Workspace.CurrentCamera
            local targetCFrame = CFrame.new(camera.CFrame.Position, targetPos)
            camera.CFrame = camera.CFrame:Lerp(targetCFrame, 1/aimbotSettings.Smoothness)
        end
    end
    
    if silentAimSettings.Enabled then
        applySilentAim()
    else
        restoreHitboxes()
    end
end)

-- Player Management
Players.PlayerRemoving:Connect(function(player)
    if espObjects[player] then
        espObjects[player].Highlight:Destroy()
        espObjects[player].Billboard:Destroy()
        espObjects[player] = nil
    end
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local originalSize = player.Character.HumanoidRootPart:FindFirstChild("OriginalSize")
        if originalSize then
            player.Character.HumanoidRootPart.Size = originalSize.Value
            player.Character.HumanoidRootPart.Transparency = 0
            player.Character.HumanoidRootPart.CanCollide = true
            originalSize:Destroy()
        end
    end
end)