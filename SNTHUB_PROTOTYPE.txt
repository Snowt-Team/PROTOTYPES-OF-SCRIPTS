local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
if not WindUI then
    warn("Не удалось загрузить WindUI!")
    return
end

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end

local Confirmed = false

WindUI:Popup({
    Title = "Hi!",
    Icon = "info",
    Content = "This script made by " .. gradient("SnowT", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")),
    Buttons = {
        {
            Title = "Cancel",
            --Icon = "",
            Callback = function() end,
            Variant = "Tertiary", -- Primary, Secondary, Tertiary
        },
        {
            Title = "Continue",
            Icon = "arrow-right",
            Callback = function() Confirmed = true end,
            Variant = "Primary", -- Primary, Secondary, Tertiary
        }
    }
})

repeat wait() until Confirmed

WindUI:Notify({
    Title = "SNT HUB",
    Content = "Скрипт успешно загружен!",
    Icon = "check-circle",
    Duration = 3,
    Background = "rbxassetid://13511292247"
})


local Window = WindUI:CreateWindow({
    Title = "Универсальный ESP/AIMBOT | SNT HUB",
    Icon = "eye",
    Author = "SnOwT",
    Folder = "SNT Hub",
    Size = UDim2.fromOffset(340, 320),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = true,
    KeySystem = {
        Key = { "SnowtTest", "SnowtRelease" },
        Note = "Введите ключ.",
        URL = "t.me/supreme_sigma",
        SaveKey = false,
    },
})

Window:EditOpenButton({
    Title = "Открыть UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("FF0F7B"),
        Color3.fromHex("F89B29")
    ),
    Draggable = true,
})

local Tabs = {
    Character = Window:Tab({ Title = "Персонаж", Icon = "file-cog", Desc = "Изменение настроек персонажа" }),
    ESP = Window:Tab({ Title = "ESP", Icon = "eye", Desc = "Визуальные модификации" }),
    Aimbot = Window:Tab({ Title = "Аимбот", Icon = "axe", Desc = "Автонаводка на врагов" }),
    Settings = Window:Tab({ Title = "Настройки", Icon = "battery", Desc = "Общие настройки" }),
    SettingsUI = Window:Tab({ Title = "Настройки UI", Icon = "cog", Desc = "Настройки пользовательского интерфейса"}),
    FileSet = Window:Tab({ Title = "Файлы", Icon = "file", Desc = "Действия с файлами."})
}

--[[ НАСТРОЙКИ ПЕРСОНАЖА ]]--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CharacterSettings = {
    WalkSpeed = {Value = 16, Default = 16, Locked = false},
    JumpPower = {Value = 50, Default = 50, Locked = false}
}

local function updateCharacter()
    local character = LocalPlayer.Character
    if not character then 
        WindUI:Notify({
            Title = "Предупреждение",
            Content = "Персонаж не найден",
            Icon = "info",
            Duration = 3
        })
        return 
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if not CharacterSettings.WalkSpeed.Locked then
            humanoid.WalkSpeed = CharacterSettings.WalkSpeed.Value
        end
        if not CharacterSettings.JumpPower.Locked then
            humanoid.JumpPower = CharacterSettings.JumpPower.Value
        end
    else
        WindUI:Notify({
            Title = "Ошибка",
            Content = "Humanoid не найден",
            Icon = "alert",
            Duration = 3
        })
    end
end

Tabs.Character:Slider({
    Title = "Скорость передвижения",
    Value = {Min = 0, Max = 200, Default = 16},
    Callback = function(value)
        CharacterSettings.WalkSpeed.Value = value
        updateCharacter()
    end
})

Tabs.Character:Button({
    Title = "Сброс скорости",
    Callback = function()
        CharacterSettings.WalkSpeed.Value = CharacterSettings.WalkSpeed.Default
        updateCharacter()
    end
})

Tabs.Character:Toggle({
    Title = "Фиксировать скорость",
    Default = false,
    Callback = function(state)
        CharacterSettings.WalkSpeed.Locked = state
        updateCharacter()
    end
})

Tabs.Character:Slider({
    Title = "Сила прыжка",
    Value = {Min = 0, Max = 200, Default = 50},
    Callback = function(value)
        CharacterSettings.JumpPower.Value = value
        updateCharacter()
    end
})


Tabs.Character:Button({
    Title = "Сброс прыжка",
    Callback = function()
        CharacterSettings.JumpPower.Value = CharacterSettings.JumpPower.Default
        updateCharacter()
    end
})

Tabs.Character:Toggle({
    Title = "Фиксировать прыжок",
    Default = false,
    Callback = function(state)
        CharacterSettings.JumpPower.Locked = state
        updateCharacter()
    end
})

--[[ СИСТЕМА ESP ]]--

local camera = workspace.CurrentCamera
local playerHighlights = {}
local textLabels = {}

local ESPSettings = {
    Names = false,
    Distance = false,
    Highlight = false,
    Color = Color3.fromRGB(255, 0, 0),
    Transparency = 0.5,
    TextColor = Color3.new(1, 1, 1),
    TextSize = 18
}

-- Настройки ESP
Tabs.ESP:Toggle({
    Title = "Показывать имена",
    Default = false,
    Callback = function(state) 
        ESPSettings.Names = state
    end
})

Tabs.ESP:Toggle({
    Title = "Показывать дистанцию",
    Default = false,
    Callback = function(state) 
        ESPSettings.Distance = state
    end
})

Tabs.ESP:Toggle({
    Title = "Подсветка игроков",
    Default = false,
    Callback = function(state) 
        ESPSettings.Highlight = state
    end
})

Tabs.ESP:Colorpicker({
    Title = "Цвет подсветки",
    Default = ESPSettings.Color,
    Callback = function(color)
        ESPSettings.Color = color
    end
})

Tabs.ESP:Input({
    Title = "Прозрачность",
    Default = 0.5,
    Callback = function(value)
        ESPSettings.Transparency = value
    end
})

Tabs.ESP:Colorpicker({
    Title = "Цвет текста",
    Default = ESPSettings.TextColor,
    Callback = function(color)
        ESPSettings.TextColor = color
    end
})

Tabs.ESP:Slider({
    Title = "Размер текста",
    Value = {Min = 12, Max = 24, Default = 18},
    Callback = function(value)
        ESPSettings.TextSize = value
    end
})

-- Основная логика ESP
local function updateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            
            -- Обработка подсветки
            if ESPSettings.Highlight and character then
                if not playerHighlights[player] then
                    playerHighlights[player] = Instance.new("Highlight")
                    playerHighlights[player].Parent = character
                end
                playerHighlights[player].FillColor = ESPSettings.Color
                playerHighlights[player].FillTransparency = ESPSettings.Transparency
            else
                if playerHighlights[player] then
                    playerHighlights[player]:Destroy()
                    playerHighlights[player] = nil
                end
            end

            -- Обработка текста
            if (ESPSettings.Names or ESPSettings.Distance) and character then
                if not textLabels[player] then
                    textLabels[player] = Drawing.new("Text")
                    textLabels[player].Outline = true
                    textLabels[player].Center = true
                end
                
                local head = character:FindFirstChild("Head")
                if head then
                    local screenPos = camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
                    if screenPos.Z > 0 then
                        local displayText = ""
                        if ESPSettings.Names then displayText = player.Name end
                        if ESPSettings.Distance then
                            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - head.Position).Magnitude
                            displayText = displayText .. " [" .. math.floor(distance) .. "]"
                        end
                        
                        textLabels[player].Text = displayText
                        textLabels[player].Position = Vector2.new(screenPos.X, screenPos.Y)
                        textLabels[player].Color = ESPSettings.TextColor
                        textLabels[player].Size = ESPSettings.TextSize
                        textLabels[player].Visible = true
                    else
                        textLabels[player].Visible = false
                    end
                end
            else
                if textLabels[player] then
                    textLabels[player].Visible = false
                end
            end
        end
    end
end

-- Автоматическое обновление
RunService.Heartbeat:Connect(updateCharacter)
RunService.RenderStepped:Connect(updateESP)

-- Очистка при выходе
Players.PlayerRemoving:Connect(function(player)
    if playerHighlights[player] then
        playerHighlights[player]:Destroy()
        playerHighlights[player] = nil
    end
    if textLabels[player] then
        textLabels[player]:Remove()
        textLabels[player] = nil
    end
end)

--[[ АИМБОТ СИСТЕМА ]]--
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local isCameraLocked = false
local lockedPlayer = nil
local defaultCameraType = Enum.CameraType.Custom
local lockRadius = 100
local cameraRotationSpeed = 0.1

local targetIndicator = Instance.new("BillboardGui")
targetIndicator.Size = UDim2.new(2, 0, 1, 0)
targetIndicator.AlwaysOnTop = true
targetIndicator.Enabled = false

local arrow = Instance.new("ImageLabel")
arrow.Size = UDim2.new(1, 0, 1, 0)
arrow.BackgroundTransparency = 1
arrow.Image = "rbxassetid://602361387"
arrow.ImageColor3 = Color3.new(1, 1, 0)
arrow.Position = UDim2.new(0.5, 0, -1.5, 0)
arrow.AnchorPoint = Vector2.new(0.5, 0.5)
arrow.Parent = targetIndicator
targetIndicator.Parent = Workspace

local function getNearestPlayer(radius)
    if not LocalPlayer.Character 
        or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") 
    then 
        return nil 
    end
    
    local nearestPlayer = nil
    local minDistance = math.huge
    local localPosition = LocalPlayer.Character.HumanoidRootPart.Position

    for _, player in Players:GetPlayers() do
        if player ~= LocalPlayer 
            and player.Character 
            and player.Character:FindFirstChild("HumanoidRootPart") 
        then
            local targetPosition = player.Character.HumanoidRootPart.Position
            local distance = (localPosition - targetPosition).Magnitude
            
            if distance <= radius and distance < minDistance then
                minDistance = distance
                nearestPlayer = player
            end
        end
    end
    
    return nearestPlayer
end

local function updateCameraLookAt()
    SafeCall(function()
    if isCameraLocked then
        -- Автоматический поиск цели если текущая невалидна
        if not lockedPlayer 
            or not lockedPlayer.Character 
            or not lockedPlayer.Character:FindFirstChild("HumanoidRootPart") 
        then
            lockedPlayer = getNearestPlayer(lockRadius)
        end

        -- Обновление позиции камеры
        if lockedPlayer and lockedPlayer.Character then
            local targetPart = lockedPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetPart then
                camera.CameraType = Enum.CameraType.Scriptable
                local newCFrame = CFrame.lookAt(camera.CFrame.Position, targetPart.Position)
                camera.CFrame = camera.CFrame:Lerp(newCFrame, cameraRotationSpeed)
                targetIndicator.Adornee = targetPart
                targetIndicator.Enabled = true
                return
            end
        end
        
        -- Сброс при отсутствии целей
        camera.CameraType = defaultCameraType
        targetIndicator.Enabled = false
    else
        camera.CameraType = defaultCameraType
        targetIndicator.Enabled = false
    end
    if not isValidTarget(lockedPlayer) then
            WindUI:Notify({
                Title = "Цель недействительна",
                Content = "Выберите другую цель",
                Icon = "info",
                Duration = 3
            })
        end
    end)
end

--[[ ОБНОВЛЕННЫЕ КОЛЛБЭКИ ]]--
Tabs.Aimbot:Toggle({
    Title = "Сфокусировать камеру на игрока",
    Default = false,
    Callback = function(state)
        isCameraLocked = state
        if state then
            lockedPlayer = getNearestPlayer(lockRadius) -- Инициализация при включении
            RunService.RenderStepped:Connect(updateCameraLookAt)
        end
    end
})

--[[ ДОПОЛНЕНИЕ ДЛЯ РУЧНОГО ВЫБОРА ЦЕЛИ ]]--
local function updatePlayerDropdown()
    local playersList = {"None"}
    for _, player in Players:GetPlayers() do
        if player ~= LocalPlayer then
            table.insert(playersList, player.Name)
        end
    end
    return playersList
end

local dropdown = Tabs.Aimbot:Dropdown({
    Title = "Ручной выбор цели",
    Values = updatePlayerDropdown(),
    Value = "None",
    Callback = function(selected)
        lockedPlayer = (selected ~= "None") and Players:FindFirstChild(selected) or nil
        if isCameraLocked and lockedPlayer then
            targetIndicator.Enabled = true
        end
    end
})

-- Автоматическое обновление списка игроков
Players.PlayerAdded:Connect(function()
    dropdown:Set("Values", updatePlayerDropdown())
end)

Players.PlayerRemoving:Connect(function(player)
    dropdown:Set("Values", updatePlayerDropdown())
    if player == lockedPlayer then
        lockedPlayer = nil
        if isCameraLocked then
            lockedPlayer = getNearestPlayer(lockRadius)
        end
    end
end)

-- Кнопка принудительного обновления
Tabs.Aimbot:Button({
    Title = "Обновить список целей",
    Callback = function()
        dropdown:Set("Values", updatePlayerDropdown())
    end
})

-- Автоматическое обновление при подключении/отключении игроков
Players.PlayerAdded:Connect(function(player)
    dropdown:Set("Values", updatePlayerDropdown())
end)

Players.PlayerRemoving:Connect(function(player)
    dropdown:Set("Values", updatePlayerDropdown())
    
    -- Если текущая цель вышла из игры
    if player == lockedPlayer then
        lockedPlayer = getNearestPlayer(lockRadius)
        if isCameraLocked and lockedPlayer then
            targetIndicator.Adornee = lockedPlayer.Character.HumanoidRootPart
        end
    end
end)

-- Индикатор выбранной цели
targetIndicator.Enabled = false
targetIndicator.Size = UDim2.new(3, 0, 3, 0)

local triangle = Instance.new("ImageLabel")
triangle.Image = "rbxassetid://4925116997" -- Красный треугольник
triangle.Size = UDim2.new(1, 0, 1, 0)
triangle.Parent = targetIndicator

-- Обновление фокуса в основном цикле
RunService.RenderStepped:Connect(function()
    if isCameraLocked then
        -- Приоритет ручного выбора
        local target = lockedPlayer or getNearestPlayer(lockRadius)
        
        if target and target.Character then
            local rootPart = target.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                -- Плавное перемещение камеры
                camera.CFrame = camera.CFrame:Lerp(
                    CFrame.lookAt(camera.CFrame.Position, rootPart.Position),
                    cameraRotationSpeed
                )
                
                -- Обновление индикатора
                targetIndicator.Adornee = rootPart
                targetIndicator.Enabled = true
                return
            end
        end
        
        -- Сброс при отсутствии целей
        targetIndicator.Enabled = false
        camera.CameraType = Enum.CameraType.Custom
    end
end)

-- Защита от ошибок при уничтожении персонажа
LocalPlayer.CharacterRemoving:Connect(function()
    if isCameraLocked then
        camera.CameraType = Enum.CameraType.Custom
        targetIndicator.Enabled = false
    end
end)

-- Фильтрация мертвых игроков
local function isValidTarget(player)
    return player and player.Character and 
        player.Character:FindFirstChild("Humanoid") and 
        player.Character.Humanoid.Health > 0
end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local Settings = {
    Hitbox = {
        Enabled = false,
        Size = 5,
        Color = Color3.new(1,0,0),
        Adornments = {},
        Connections = {}
    },
    Noclip = {
        Enabled = false,
        Connection = nil
    },
    AntiAFK = {
        Enabled = false,
        Connection = nil
    }
}
local function SafeCall(fn)
    local s, err = pcall(fn)
    if not s then 
        WindUI:Notify({
            Title = "Ошибка",
            Content = "Произошла ошибка: " .. tostring(err),
            Icon = "alert",
            Duration = 5,
            Background = "rbxassetid://13511292247"
        })
    end
    return s
end


-- Ноклип
local function ToggleNoclip(state)
    SafeCall(function()
        if state then
            Settings.Noclip.Connection = RunService.Stepped:Connect(function()
                local chr = LocalPlayer.Character
                if chr then
                    for _, part in pairs(chr:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if Settings.Noclip.Connection then
                Settings.Noclip.Connection:Disconnect()
            end
        end
    WindUI:Notify({
            Title = "Ноклип",
            Content = state and "Активирован" or "Деактивирован",
            Icon = "check-circle",
            Duration = 2
        })
    end)
end

-- Хитбоксы
local function UpdateHitboxes()
    SafeCall(function()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local chr = plr.Character
                local box = Settings.Hitbox.Adornments[plr]
                
                if chr and Settings.Hitbox.Enabled then
                    local root = chr:FindFirstChild("HumanoidRootPart")
                    if root then
                        if not box then
                            box = Instance.new("BoxHandleAdornment")
                            box.Adornee = root
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                            box.Transparency = 0.4
                            box.ZIndex = 10
                            box.Parent = root
                            Settings.Hitbox.Adornments[plr] = box
                        else
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                        end
                    end
                elseif box then
                    box:Destroy()
                    Settings.Hitbox.Adornments[plr] = nil
                end
            end
        end
    end)
end

-- Анти-AFK
local function ToggleAntiAFK(state)
    SafeCall(function()
        if state then
            Settings.AntiAFK.Connection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
                end)
            end)
        else
            if Settings.AntiAFK.Connection then
                Settings.AntiAFK.Connection:Disconnect()
            end
        end
        WindUI:Notify({
            Title = "Анти-AFK",
            Content = state and "Активирован" or "Деактивирован",
            Icon = "check-circle",
            Duration = 2
        })
    end)
end

-- Интерфейс

Tabs.Settings:Toggle({
    Title = "Ноклип",
    Callback = function(state)
        Settings.Noclip.Enabled = state
        ToggleNoclip(state)
    end
})

Tabs.Settings:Toggle({
    Title = "Хитбоксы",
    Callback = function(state)
        Settings.Hitbox.Enabled = state
        if state then
            RunService.Heartbeat:Connect(UpdateHitboxes)
        else
            for _, box in pairs(Settings.Hitbox.Adornments) do
                box:Destroy()
            end
            Settings.Hitbox.Adornments = {}
        end
    end
})

Tabs.Settings:Slider({
    Title = "Размер хитбокса",
    Value = {Min=1, Max=10, Default=5},
    Callback = function(val)
        Settings.Hitbox.Size = val
        UpdateHitboxes()
    end
})

Tabs.Settings:Colorpicker({
    Title = "Цвет хитбокса",
    Default = Color3.new(1,0,0),
    Callback = function(col)
        Settings.Hitbox.Color = col
        UpdateHitboxes()
    end
})

Tabs.Settings:Toggle({
    Title = "Анти-AFK",
    Callback = function(state)
        Settings.AntiAFK.Enabled = state
        ToggleAntiAFK(state)
    end
})

-- Очистка
game:BindToClose(function()
    ToggleNoclip(false)
    ToggleAntiAFK(false)
    for _,v in pairs(Settings.Hitbox.Adornments) do v:Destroy() end
end)

local HttpService = game:GetService("HttpService")

local folderPath = "WindUI"
if not isfolder(folderPath) then
    pcall(function()
        makefolder(folderPath)
    end)
end
makefolder(folderPath)

local themeValues = {}
local themes = WindUI:GetThemes()
if themes then
    for name, _ in pairs(themes) do
        table.insert(themeValues, name)
    end
end

local themeDropdown = Tabs.SettingsUI:Dropdown({
    Title = "Выбери тему",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

if WindUI:GetCurrentTheme() then
    themeDropdown:Select(WindUI:GetCurrentTheme())
end

local currentThemeName = WindUI:GetCurrentTheme() or "Default"
local themes = WindUI:GetThemes() or {} -- Обработка отсутствия тем

local ThemeAccent = themes[currentThemeName] and themes[currentThemeName].Accent or Color3.fromHex("#FFFFFF")
local ThemeOutline = themes[currentThemeName] and themes[currentThemeName].Outline or Color3.fromHex("#000000")
local ThemeText = themes[currentThemeName] and themes[currentThemeName].Text or Color3.fromHex("#FFFFFF")
local ThemePlaceholderText = themes[currentThemeName] and themes[currentThemeName].PlaceholderText or Color3.fromHex("#808080")

function updateTheme()
    WindUI:AddTheme({
        Name = currentThemeName,
        Accent = ThemeAccent,
        Outline = ThemeOutline,
        Text = ThemeText,
        PlaceholderText = ThemePlaceholderText
    })
    WindUI:SetTheme(currentThemeName)
    WindUI:Notify({Title = "Тема обновлена!", Content = currentThemeName, Duration = 2}) -- Уведомление для отладки
end

local ToggleTransparency = Tabs.SettingsUI:Toggle({
    Title = "Прозрачность интерфейса",
    Default = WindUI:GetTransparency() or false, -- Значение по умолчанию
    Callback = function(e)
        Window:ToggleTransparency(e)
    end
})


local CreateInput = Tabs.SettingsUI:Input({
    Title = "Название темы",
    Value = currentThemeName,
    Callback = function(name)
        currentThemeName = name
    end
})

Tabs.SettingsUI:Colorpicker({
    Title = "Цвет фона",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color:ToHex()
    end
})

Tabs.SettingsUI:Colorpicker({
    Title = "Цвет границ UI",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color:ToHex()
    end
})

Tabs.SettingsUI:Colorpicker({
    Title = "Цвет текста",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color:ToHex()
    end
})

Tabs.SettingsUI:Colorpicker({
    Title = "Цвет заполнителя текста",
    Default = Color3.fromHex(ThemePlaceholderText),
    Callback = function(color)
        ThemePlaceholderText = color:ToHex()
    end
})

Tabs.SettingsUI:Button({
    Title = "Обновить тему",
    Callback = function()
        updateTheme()
    end
})

local function SaveFile(fileName, data)
    if not writefile then 
        WindUI:Notify({Title = "Ошибка", Content = "Файловая система недоступна!", Icon = "alert"})
        return
    end
    local filePath = folderPath .. "/" .. fileName .. ".json"
    local jsonData = HttpService:JSONEncode(data)
    writefile(filePath, jsonData)
end

local function LoadFile(fileName)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    if isfile(filePath) then
        local jsonData = readfile(filePath)
        return HttpService:JSONDecode(jsonData)
    end
end

-- Исправленная функция ListFiles
local function ListFiles()
    local files = {}
    if isfolder(folderPath) then
        for _, file in ipairs(listfiles(folderPath)) do
            local fileName = file:match(".+/(.+)%.json$") -- Исправлен паттерн
            if fileName then
                table.insert(files, fileName)
            end
        end
    end
    return files
end

-- Инициализация дропдауна при создании
local files = ListFiles()
local filesDropdown = Tabs.FileSet:Dropdown({
    Title = "Выбрать файл",
    Values = files,
    Callback = function(selectedFile)
        fileNameInput = selectedFile
    end
})

-- Исправление кнопки "Обновить список"
Tabs.FileSet:Button({
    Title = "Обновить список",
    Callback = function()
        filesDropdown:Refresh(ListFiles()) -- Принудительное обновление
    end
})


local fileNameInput = ""
Tabs.FileSet:Input({
    Title = "Напиши название файла",
    PlaceholderText = "Enter file name",
    Callback = function(text)
        fileNameInput = text
    end
})

Tabs.FileSet:Button({
    Title = "Сохранить файл",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.FileSet:Button({
    Title = "Загрузить файл",
    Callback = function()
        if fileNameInput ~= "" then
            local data = LoadFile(fileNameInput)
            if data then
                if data.Transparent ~= nil then 
                    Window:ToggleTransparency(data.Transparent)
                    ToggleTransparency:SetValue(data.Transparent)
                end
                if data.Theme then 
                    WindUI:SetTheme(data.Theme)
                    themeDropdown:Select(data.Theme)
                end
            end
        end
    end
})

Tabs.FileSet:Button({
    Title = "Перезаписать файл",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.FileSet:Button({
    Title = "Обновить список",
    Callback = function()
        filesDropdown:Refresh(ListFiles())
    end
})
